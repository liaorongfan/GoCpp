/*************************************************************************
	> File Name: 12-friend.cpp
	> Author: 
	> Mail: 
	> Created Time: Sat 09 Oct 2021 04:46:31 PM CST
 ************************************************************************/

#include<iostream>
using namespace std;

#define BEGINS(x) namespace x {
#define ENDS(x) } // end of namespace x


BEGINS(haizei)
class Point {
public:
    /*
     * 类的有参构造函数：Point(int x, int y): x(x), y(y) {}
     *
     * x(x): 括号内的x表示Point(int x, int y)中的型参
     * 括号外的x 表示成员属性 x
     *
     */
    Point(int x, int y): x(x), y(y) {} 
    
    void output() {
        cout << "INNER: " << x << " " << y << endl;
        return ;
    }
    // 这里返回的是一个临时对象，不可以返回引用，而返回值
    Point operator+(int x) const {  
        return Point(this->x + x, this->y + x);
    }
    // 运算符 返回类型 取决与函数功能设计
    Point &operator+=(int x) {
        this->x += x;
        this->y += y;
        return *this;
    }
    // p++ 将P值加1，但返回加1之前的p值，这里要返回的是值
    // 不需传引用
    Point operator++(int) {
        Point ret(*this);
        this->x += 1;
        this->y += 1;
        return ret;
    }
    friend void output(Point &); 
    friend ostream &operator<<(ostream &, const Point &);
    friend Point operator+(const Point &, const Point &);

private:
    int x, y;

};

void output(Point &a) {
    cout << "OUTER: " << a.x << " " << a.y << endl;
    return ;
}

/*
 * 重载输出运算符 << 时， 返回值为 ostream 类型的引用
 * 是方便 运算符的连续使用 << a << b << c;
 *
 */
ostream &operator<<(ostream &out, const Point &p) {
    out << "Point(" << p.x << ", " << p.y << ")";
    return out;
}
/*
 * 类外重载 + 法运算符
 */
Point operator+(const Point &a, const Point &b) {
    return Point(a.x + b.x, a.y + b.y);
}

ENDS(haizei)

BEGINS(test1)
using namespace haizei;
int main() {
    Point p(3, 4), q(5, 6);
    p.output();
    output(p);
    cout << p << endl;
    cout << (p + q) << endl;
    cout << (p + 5) << endl; // 编译器对于 p + 5 => p.operator+(5)
    return 0;
}
ENDS(test1)



BEGINS(test2)
using namespace haizei;

int main() {
    // +=
    Point p(3, 4);
    p += 5;
    cout << ((p += 5) += 6) << endl;
    // p++ , ++p
    cout << (p++) << endl; 
    cout << p << endl;
    return 0;
}



ENDS(test2)


int main() {

    test2::main();
    return 0;
}















